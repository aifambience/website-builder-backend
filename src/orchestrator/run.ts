import { v4 as uuidv4 } from "uuid";
import { getEnv } from "../env.js";
import { createRepo, pushAllFiles } from "../github.js";
import { generateFilesFromLLM, fixFilesFromLLM } from "../llm/generateFiles.js";
import { saveRun } from "../store.js";
import { createVercelProject } from "../vercel.js";
import { validateBuild } from "../builder/validateBuild.js";

function sanitizeRepoName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .replace(/-{2,}/g, "-")
    .slice(0, 50);
}

function generateRepoName(prompt: string): string {
  const prefix = process.env.GITHUB_REPO_PREFIX || "ai-site-";
  const slug = sanitizeRepoName(prompt.split(" ").slice(0, 5).join(" ")) || "run";
  const shortId = uuidv4().split("-")[0];
  return `${prefix}${slug}-${shortId}`;
}

export async function runPromptToRepo(input: {
  prompt: string;
  repoName?: string;
  isPrivate?: boolean;
  skill?: string;
  colorTheme?: string;
}) {
  // Generate runId upfront so every log line is traceable
  const runId = uuidv4().split("-")[0];
  const log = (msg: string) => console.log(`[run ${runId}] ${msg}`);

  const { owner, vercelToken } = getEnv();
  const repoName = input.repoName?.trim()
    ? sanitizeRepoName(input.repoName.trim())
    : generateRepoName(input.prompt);

  // ── Step 1: LLM ─────────────────────────────────────────────────────────
  // Run this BEFORE creating the GitHub repo so a failed LLM call never
  // leaves an empty ghost repo behind.
  log(`calling LLM (skill=${input.skill ?? "default"}, theme=${input.colorTheme ?? "default"})...`);
  let generated = await generateFilesFromLLM(input.prompt, input.skill, input.colorTheme);
  log(`LLM done → ${generated.files.length} files, title="${generated.siteTitle}"`);

  // ── Step 1b: Validate build (with LLM retry loop) ───────────────────────
  // Only push code to GitHub once we know it compiles.
  const MAX_RETRIES = 2;
  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    log(`validating build (attempt ${attempt + 1}/${MAX_RETRIES + 1})...`);
    const validation = await validateBuild(runId, generated.files);

    if (validation.success) {
      log(`build validation passed`);
      break;
    }

    log(`build validation failed: ${validation.error?.slice(0, 200)}`);

    if (attempt === MAX_RETRIES) {
      throw new Error(
        `Build validation failed after ${MAX_RETRIES + 1} attempts. Last error:\n${validation.error}`
      );
    }

    log(`asking LLM to fix build errors (retry ${attempt + 1})...`);
    generated = await fixFilesFromLLM(
      input.prompt,
      generated,
      validation.error ?? "Build failed",
      input.skill,
      input.colorTheme
    );
    log(`LLM fix done → ${generated.files.length} files`);
  }

  // ── Step 2: Create GitHub repo ───────────────────────────────────────────
  log(`creating repo "${repoName}"...`);
  const repo = await createRepo(repoName, input.isPrivate ?? false);
  log(`repo created → ${repo.html_url}`);

  // ── Step 3: Push all files in one commit ─────────────────────────────────
  log(`pushing ${generated.files.length} files...`);
  let commitSha: string;
  try {
    const pushed = await pushAllFiles(
      owner,
      repo.name,
      generated.files,
      "feat: initial site generated by AI",
      repo.default_branch
    );
    commitSha = pushed.commitSha;
  } catch (err) {
    log(`push failed: ${(err as Error).message}`);
    throw err;
  }
  log(`files pushed → commit ${commitSha.slice(0, 7)}`);

  // ── Step 4: Vercel deployment ────────────────────────────────────────────
  let vercelProjectId: string | undefined;
  let vercelUrl: string | undefined;
  if (vercelToken) {
    log(`creating Vercel project...`);
    try {
      const vercel = await createVercelProject(vercelToken, repo.name, owner, repo.name, repo.id, commitSha, repo.default_branch);
      vercelProjectId = vercel.projectId;
      vercelUrl = vercel.url;
      log(`Vercel project created → ${vercelUrl}`);
    } catch (err) {
      log(`Vercel project creation failed (non-fatal): ${(err as Error).message}`);
    }
  }

  // ── Step 5: Persist run metadata ─────────────────────────────────────────
  saveRun({
    runId,
    owner,
    repo: repo.name,
    repoUrl: repo.html_url,
    defaultBranch: repo.default_branch,
    prompt: input.prompt,
    createdAt: new Date().toISOString(),
    buildStatus: "pending",
    vercelProjectId,
    vercelUrl,
  });
  log(`run saved`);

  return {
    runId,
    owner,
    repo: repo.name,
    repoUrl: repo.html_url,
    defaultBranch: repo.default_branch,
    filesWritten: generated.files.map((f) => f.path),
    buildStatus: "pending" as const,
    ...(vercelUrl ? { vercelUrl } : {}),
  };
}
